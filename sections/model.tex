\section{Model}
\label{sec:model}

The vocabulary used throughout this document is summarized in the IPC Glossary \cite{glossary}.
The reader is encouraged to read the IPC Glossary before continuing.

\matej{When the Glossary becomes stable, we can maybe add it as an appendix to this document.}

\subsection{Computation and failure model}

We model \ipc as a distributed (``message-passing") system consisting of \emph{processes} that communicate by exchanging \emph{messages}%
\footnote{Network messages are not to be confused with Filecoin actor messages, that this document refers to as transactions.}
over a network. 
In practice, a process is a program running on a computer, having some state, and reacting to external events and messages received over a communication network.
We describe processes as exemplified in \Cref{alg:process-definition}.

\begin{algorithm}[H]
\footnotesize
\caption{Process definition.}\label{alg:process-definition}
  \DontPrintSemicolon
  \SetKwProg{Component}{$\blacktriangleright$ \bf}{:}{\KwRet}
  \SetKwFor{UponKW}{upon}{do}{fintq}
  \SetKw{Trigger}{trigger}
  variable = initial value\\
  variable = initial value\\
  ...\\
  \Component{process}{
     \UponKW{event(params...)}{
       \tcp{Logic to execute atomically}
     }
     \UponKW{message(params...)}{
       \tcp{Logic to execute atomically}
     }
     ...
}
\end{algorithm}

A process that performs all the steps exactly as prescribed by the protocols it is participating in is \emph{correct}.
A process that stops performing any steps (i.e., \emph{crashes}) or that deviates from the prescribed protocols in any way is \emph{faulty}.
If a process is correct or may only fail by crashing, it is \emph{benign}.
A non-benign process is \emph{malicious}.
\matej{We can remove terms we end up not using...}

In general, faulty processes can be malicious (Byzantine), i.e., we do not put any restrictions on their behavior, except being computationally bounded and thus not being able to subvert standard cryptographic primitives, such as forging signatures or inverting secure hash functions.
If the implementation of some component in our design requires additional assumptions on the behavior of faulty processes, they will be stated explicitly.
% We do not make a general statement about the fault tolerance of \ipc as a system, as to how many faulty processes the system can sustain.
% This depends on the final implementation of its components.

We use the term \emph{participant} to describe an entity participating in the system that controls one or more processes.
All processes controlled by one participant are assumed to be in the same trust domain -- they trust each other, i.e., assume each other's correctness.
For example, a participant in the child subnet will probably run multiple processes:
one for participating in the child subnet's protocol (child replica),
one for participating in the parent subnet (parent replica),
and one process that processes the information from the above two and submits transactions accordingly (\ipc agent).
We precisely define the replicas and the \ipc agent (all of them being processes) in \Cref{sec:components,sec:smr}.
The \ipc agent of a participant always assumes that the information it receives from "its own" child replica is correct.
However, messages received from another participant's replica or \ipc agent are seen as potentially malicious.

The synchrony assumptions may vary between different components of \ipc.
We thus state those assumptions whenever necessary, when describing concrete implementations of \ipc components.

\subsection{State machine replication (SMR) and \dapps}
\label{sec:smr}

\paragraph{SMR and replicated state.}
A \emph{state machine replication (SMR) system}%
\footnote{In this document, we use the terms ``SMR system" and ``blockchain" interchangeably.}
is a system consisting of processes called \emph{replicas}, each of which locally stores a copy of (or at least has access to) \emph{replicated state}
that it updates over time by applying a sequence of \emph{transactions} to it.
Without specifying the details of it, we assume that any process can \emph{submit} a transaction to an SMR system (we call such a process an \emph{SMR client})
and that this transaction will eventually be ordered and applied to the replicated state.
We call an SMR system that is part of \ipc a \emph{subnet}.

An SMR system guarantees to each correct replica that, after applying $n$ transactions to its local copy of the replicated state,
the latter will be identical to any other correct replica’s copy of the replicated state after applying $n$ transactions.
The replicas achieve this by executing an \emph{ordering protocol} to agree on a common sequence of transactions to apply to the replicated state.

Note that replicas do not necessarily all hold the same replicated state at any instant of real time,
since each replica might be processing transactions at a different time.
In this context, there is no such thing as “the current replicated state of the SMR system”.
There is only the current replicated state of a single replica.
The replicated state of the system is only an abstract, logical construct
useful for reasoning about transitions from one replicated state to another,
happening at individual replicas by applying transactions (at different real times).
When referring to a “current” replicated state, we mean the state resulting from the application of a certain number of transactions to the initial state.

\paragraph{Smart contracts.}
The replicated state of an SMR system can be logically subdivided into multiple \emph{\dapps} (a.k.a. actors in Filecoin).
A \dapp is a portion of the replicated state with well-defined semantics.
It defines the logic (e.g., expressed in a programming language, like Solidity in Ethereum)
that a replica needs to execute when applying transactions and the new state that results from it.

We model a \dapp as a logical object in the replicated state that contains arbitrary variables representing its state.
Its associated logic reacts to \emph{events} triggered by (1) the application of transactions or (2) execution of other (or even own) smart contract logic. We describe smart contracts as exemplified in \Cref{alg:dapp-definition}.

\begin{algorithm}[H]
\footnotesize
\caption{\dapp definition}\label{alg:dapp-definition}
  \DontPrintSemicolon
  \SetKwProg{Component}{$\blacktriangleright$ \bf}{:}{\KwRet}
  \SetKwFor{UponKW}{upon}{do}{fintq}
  \SetKw{Trigger}{trigger}
  variable = initial value\\
  variable = initial value\\
  ...\\
  \Component{\dapp name}{
     \UponKW{event(params...)}{
       \tcp{Logic to execute}
       \Trigger event(params...)
     }
     \UponKW{tx(params...)}{
       \tcp{Logic to execute}
       \Trigger event(params...)
     }
     ...
}
\end{algorithm}
Note that, despite using similar syntax to describe processes and \dapps, those are fundamentally different.
The former usually represent OS-level processes running on some physical machine,
the latter are an abstraction over the replicated state of an SMR system and their logic is being executed by all its replicas.
While a process can submit a transaction to an SMR system, a \dapp cannot.

\paragraph{Interaction between subnets.}
In \ipc, whole subnets need to interact, i.e., the replicated state of one subnet must react to (changes in) the replicated state of another subnet.
As the replicated state of every subnet is distributed among its replicas and evolves independently of other subnets,
we must establish a mechanism for interactions between the states of subnets.
In particular, we must explicitly link the two replicated states of two subnets.
More precisely, for any interaction between two subnets ($A$ and $B$), define block heights $h_A$ and $h_B$,
such that $A$'s replicated state at height $h_A$ considers $B$'s replicated state to have evolved exactly until $h_B$.

\paragraph{\PofsFull.}To this end, we define a \emph{\pofFull (\pof)} to be data that proves that an SMR system definitively reached a certain replicated state.
Regardless of the SMR system's ordering protocol's approach to finality (e.g., immediate finality for classic BFT protocols, or probabilistic finality in PoW-based systems),
a \pof convinces the the proof's verifier that the replicated state the \pof refers to will not be rolled back.
For example, for a BFT-based SMR system, a quorum of signatures produced by its replicas can constitute a \pof.
We denote by \emph{\pof(tx)} the proof that an SMR system reached a state in which transaction \emph{tx} already has been applied.



\subsection{Money}

For each pair of subnets in a parent-child relationship, we assume that there exists a notion of \emph{money} (measured in \emph{coins}) common to both subnets.%
\footnote{One can easily generalize the design to decouple the use of money between a parent and its child, but we stick with using the same kind of money in both subnets for simplicity.}
Each end user of the SMR system is assumed to have a personal wallet and a corresponding account in some subnet.

We also assume that the submission, ordering, and applications of transactions is associated with a monetary cost.
Each SMR client submitting a transaction to a subnet is assumed to have an account in that subnet, from which this cost is deducted.
If the funds are insufficient, the SMR system ignores the transaction.