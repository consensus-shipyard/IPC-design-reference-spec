\section{Pseudo-code}\label{sec:pseudocode}
In \cref{alg:join,alg:down,alg:up} we omit the fee paid by user~$\user$ to the governance account of subnet~$\SN_C$.
\begin{algorithm}[ht]
\caption{Join (very similar to move funds down)}\label{alg:join}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwFor{UponKW}{upon}{do}{fintq}
  \Input{user~$\user$, child subnet~$\SN_C$, parent subnet~$\PN_P$, amount~$\fil$}
    verify that $\user$ has an account in $\SN_P$ and that it has enough funds in $\SN_P$\;
    remove $\fil$ funds from $\user$'s account in $\SN_C$\;
    add  to the down-$\tx$-Batch the transaction: $\tx_\textit{create}(\user,\fil)$ instantiating an account for $\user$ with $\fil$ funds in $\SN_C$\;
    \UponKW{Propose down-$\tx$-Batch}{
        gov-account proposes down-$\tx$-Batch in $\SN_C$ with fee~$fee$ from $\SN_C$ governance account \tcp*[r]{this is an option for paying the fee.}
    }

    \UponKW{Execute down-$\tx$-Batch (in $\SN_P$)}{
        \For{each $\tx_\textit{create}$ in down-$\tx$-Batch}{
            $(\user,\fil)\gets \tx_\textit{create}$\;
            add account in $\SN_C.\textit{accounts}$ for user~$\user$
            add $\fil$ funds to $\user$'s account in $\SN_C$
        }
    } 
\end{algorithm}
%%=============================%%

%%=============================%%
\begin{algorithm}[ht]
\caption{Move funds down}\label{alg:down}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwFor{UponKW}{upon}{do}{fintq}
  \Input{user~$\user$, parent subnet~$\SN_P$, child subnet~$\SN_C$, amount~$\fil$}
  verify that $\user$ has accounts in both $\SN_P$ and $\SN_C$, and that it has enough funds in $\SN_P$\;
  remove $\fil$ fund from $\user$'s account in $\SN_P$\;
  add $\tx$ increasing $\user$'s account in $\SN_C$ by $\fil$ to the down-$\tx$-Batch\;
  
    \UponKW{Propose down-$\tx$-Batch}{
        gov-account proposes down-$\tx$-Batch in $\SN_C$ with fee~$fee$ from $\SN_C$ governance account \tcp*[r]{this is an option for paying the fee.}
    }

    \UponKW{Execute down-$\tx$-Batch (in $\SN_C$)}{
        \For{each $\tx$ in down-$\tx$-Batch}{
            $(\user,\fil)\gets \tx$\;
            add $\fil$ funds to $\user$'s account in $\SN_C$
        }
    }\tcp*[r]{If execution continuously fails (due to not enough fee) the money is lost.}

\end{algorithm}
%%=============================%%

%%=============================%%
\begin{algorithm}[ht]
\caption{Move funds up}\label{alg:up}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwFor{UponKW}{upon}{do}{fintq}
    \Input{user~$\user$, child subnet~$\SN_C$, parent subnet~$\SN_P$, amount~$\fil$}
  verify that $\user$ has accounts in both $\SN_C$ and $\SN_P$, and that it has enough funds in $\SN_C$\;
  remove $\fil$ funds from $\user$'s account in $\SN_C$\;
  add $\tx$ increasing $\user$'s account in $\SN_P$ by $\fil$ to the up-$\tx$-Batch\;
  
    \UponKW{Propose up-$\tx$-Batch}{
        gov-account proposes up-$\tx$-Batch in $\SN_P$ with fee~$fee$ from $\SN_C$ governance account \tcp*[r]{this is an option for paying the fee.}
    }

    \UponKW{Execute up-$\tx$-Batch (in $\SN_P$)}{
        \For{each $\tx$ in up-$\tx$-Batch}{
            $(\user,\fil)\gets \tx$\;
            add $\fil$ funds to $\user$'s account in $\SN_P$
        }
    }\tcp*[r]{If execution continuously fails (due to not enough fee) the money is lost.}
\end{algorithm}
%%=============================%%

%%=============================%%
\begin{algorithm}[ht]
\caption{Create Checkpoint}\label{alg:ckpt}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwFor{UponKW}{upon}{do}{fintq}
  
    \Input{\textit{prevCP}}
    \textit{newCP}$\gets$ get-snapshot($\SN_C$) \tcp*[r]{a recent state of $\SN_C$ individual accounts}
    verify-snapshot(\textit{newCP}) \tcp*[r]{E.g., a valid successor of \textit{prevCP} and signed by majority of validators.}
    \textit{diff}$\gets$ calculate diff from prevCP\;
    propose in $\SN_P$ to update \textit{prevCP} with \textit{diff} \tcp*[r]{fee should be paid from governance account}
    \For{each validator in $\SN_C$}{
        \UponKW{application of \textit{newCP} in $\SN_P$}{
            only offspring of \textit{newCP} will now be validated
        }
    }
\end{algorithm}
%%=============================%%

%%=============================%%
\begin{algorithm}[ht]
\caption{Default fee setting algorithm}\label{alg:fee}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwFor{UponKW}{upon}{do}{fintq}
  
to do...
\end{algorithm}
%%=============================%%

%%=============================%%
\begin{algorithm}[ht]
\caption{Example slashing mechanism (Depends on specific consensus mechanism)}\label{alg:slash}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwFor{UponKW}{upon}{do}{fintq}
    \Input{\textit{validator, proof}}  
    \If{\textit{proof} that \textit{validator} voted for more than 1 block in epoch}{
        slash \textit{validator} completely
    }
    \If{\textit{proof} that \textit{validator} proposed more than 1 block in epoch}{
        slash \textit{validator} completely
    }
    \If{\textit{proof} that \textit{validator} proposed more than 1 block in epoch}{
        slash \textit{validator} completely
    }
    \If{\textit{proof} that \textit{validator} proposed an invalid block}{
        slash \textit{validator} by a factor of $1/10$
    }

\end{algorithm}
%%=============================%%