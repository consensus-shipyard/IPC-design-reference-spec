 % - Implementations/templates
 %  - Different types and trade-offs of checkpoint triggers 
 %    - Periodically: time, #blocks, #withdrawn, etc.
 %    - At request: (this one is not governance funded)
 %    - Combinations of these 
 %    - Slashing functions
 %    - Atomic execution types?
 \section{IPC's reference implementation}
 \label{sec:ref-impl}
 
% \jorge{I like the idea of the section but it currently reads a little weird, particularly beyond 8.1. There is this list of components/topics and a number of entries under them, but no narrative and, for many of the entries, it's unclear whether the implementation details actually add useful details, vs. just repeating the design or listing implementation "facts" without explaining their relevance. I don't know if the solution is less content of more content, but I might start with making it less "entry"-based and more narrative, focusing on things that are either very relevant/important os potentially unexpected and hence deserving of an explanation. I think e.g. 8.4 (incentives) is written in a more useful style.}

 The reference implementation of IPC differs slightly from the description of the functionality and implementation shown in previous sections, partly due to the rapidly changing development of the system, and partly due to its concurrent implementation simultaneous with the design and improvement of the system. In this section, we describe the particular implementation choices for the reference implementation of IPC. It is not the purpose of this section to comprehensively describe the reference implementation, but to list the relevant differences of the current reference implementation compared with the description of IPC made in previous sections, as well as to list the pertinent implementation decisions of abstractions such as the \pof or the consensus protocol used by the reference implementation.

 \subsection{Preliminaries}
 The current implementation considers Filecoin~\cite{filecoin} as the rootnet and Trantor~\cite{trantor} running in child subnets, both running as the consensus layer of the Lotus blockchain client~\cite{lotus}. Filecoin is a Proof-of-Storage, longest-chain-style protocol with probabilistic finality.
 For our purposes, we note that Trantor is a BFT-style protocol that iterates through instances of PBFT \cite{castro1999practical} with immediate finality. Every decided block in Trantor contains an ordered list of decided transactions and a certificate for verification, with every $\Delta$-th block containing a checkpoint of the state. At the moment, the checkpoint being generated by Trantor is a certificate of the latest decided block provided by the Lotus client.
 
 The reference implementation makes use of IPFS-style content addressing, in that data is stored where relevant and referred to with a Multiformats-compliant~\cite{multiformats} content identifier (CID) elsewhere. In particular, CIDs that address information of a specific child's subnet can be used to retrieve the content through BitSwap~\cite{bitswap} from any of the participants running \glspl{full-node} of the subnet. This means that if a subnet only has faulty participants, the content referred to by this CID may not be available. However, this is not a problem, as IPC still preserves the subnet firewall property (\cref{sec:preliminaries}).

The reference implementation uses the Filecoin Virtual Machine (FVM) as the runtime environment in which the \gw and the \sa are deployed. Both actors are user-defined, in that any user can deploy their own modifications of the provided actors, and use them to interact with the rest of the IPC hierarchy.


\subsection{Components}
The IPC reference implementation preserves all the components described in~\cref{sec:components} without additions. We however list here implementation decisions concerning these components. The two main design decisions are $(i)$ to have one IPC agent manage the interactions across all subnets, and not one per parent-child pair, and $(ii)$ to make the \gw the entry point for all IPC functionality, with the possibility to augment the default functionality for a specific subnet with the \sa.

 \subsubsection{IPC agent} 
 \label{sec:refimplipcagent}
 In the previous sections, we considered that every parent-child pairing had an independent IPC agent process. In fact, the implementation manages to execute one single IPC agent for the entire tree of subnets that may be of relevance to a participant. This process can be executed either as a daemon or as a command-line tool. In the latter case, the IPC agent cannot participate in either checkpointing or propagating cross-net transactions. We refer to the participants running the IPC agent as a command-line tool as the IPC clients.

While a participant only runs one \ipc anget, it also runs a full node for each subnet that the participant is involved in. The IPC agent process along with all the full nodes relevant to a participant conform the participant's \emph{\gls{trust domain}}. All processes within the same trust domain assume each other's correctness.
As a result, the IPC agent can be notified of changes to the state of each of the full nodes locally run by the participant.
\subsubsection{\gw as entry point}
\label{sec:gwrefimpl}

In the reference implementation, the entry point for all functionality is the \gw, unlike in the high-level functionality described in~\cref{sec:functionality}. For any of the provided functionalities, the IPC agent submits transactions to the \gw (e.g. \gw.\funcName{Deposit}(\subnetName{C}, \funcParam{amt}, \funcParam{...})). For bottom-up transactions, the child's \gw communicates with the \sa of the child at the parent. For top-down transactions, the \gw of the parent directly communicates with the \gw at the child. Nonetheless, the IPC agent never communicates with the \sa directly, but indirectly through an \gw.

% In addition, it contains variables relevant for the functionality, namely $(i)$ the minimum required total stake per child subnet, in that a child subnet becomes inactive if it drops below the minimum (see~\cref{sec:refimplsa}; $(ii)$ the checkpoint period $\Delta$, specifying the distance (in blocks) that must be maintained between checkpoints (see~\cref{sec:refimplfunc}); and $(iii)$ CIDs of child subnets' checkpoints, that are propagated during its own checkpoints (see~\cref{sec:refimplfunc}).

     % \paragraph{Circulating supply.} 
     As a result, in the reference implementation, the \gw contains the locked funds of each subnet, i.e. the subnet's \textit{circulating supply} (unlike in \cref{sec:components}, where the \sa held the locked funds). The circulating supply of each child subnet is stored in a map at the \gw, where the key is the subnet ID. As withdrawals contain a \pof, the circulating supply suffices for the firewall property.

     % \paragraph{Cross-net transactions.} Cross-net transactions are batched together when being sent to a subnet \subnetName{S$_1$} from another subnet \subnetName{S$_2$}, with bottom-up transactions being attached to and sent with childrens' checkpoints. The \gw is in charge of executing cross-net transactions. We explain further the data structures and procedures involving cross-net transactions in~\cref{sec:cnetrefimpl}.

% The \gw is the entry point of all functionality in the reference implementation. The state of \subnetName{C}'s \gw consists of: 
% \begin{enumerate}
%     \item {\bf Basic variables and pointers.} The \gw stores a pointer to the parent's subnet, and to each of its children. 
%     \item {\bf Generic checks and implementation of functionality.} As the entry point for IPC operations, the \gw implements all functionality with calls to the subnet-specific checks and operations specified in the \sa of the child. In addition, it contains variables relevant for the functionality, namely: 
%     \begin{itemize}
%         \item the minimum required total stake per child subnet, in that a child subnet becomes inactive if it drops below the minimum;
%         \item the checkpoint period $\Delta$, specifying the distance (in blocks) that must be maintained between checkpoints (see~\cref{sec:refimplfunc}); and
%         \item CIDs of child subnets' checkpoints, that are propagated during its own checkpoints (see~\cref{sec:refimplfunc}).
%     \end{itemize}
    
%     \item{ \bf Funds and collateral.} The \gw holds the funds of all deposits to the children subnets and the stake kept as collateral of each child subnet.
%     \item {\bf State concerning the execution of cross-net transactions.} Cross-net transactions are batched together when being sent to a subnet from another subnet, with bottom-up transactions being attached to and sent with childrens' checkpoints. The \gw is in charge of executing and storing cross-net transactions. We explain further the data structures and procedures involving cross-net transactions in~\cref{sec:cnetrefimpl}.
% \end{enumerate} 

% \TODO{add sequence diagram}

% \jorge{Structure-wise, this is a bit weird. We say there are two key differences (IGA and consolidated agent), then proceed to list two decisions (and the IGA isn't the first). Then we provide an example of something (not sure what it's meant to exemplify?) that is listed in line with the implementation details. And the agent comes in its own subsection. Suggestion: let's make everything below this into subsections (or merge into existing ones). And please contextualise that example (either here or in subsection) as I really don't know what it's supposed to illustrate.}

\subsubsection{\sa for subnet customization}
\label{sec:refimplsa} In the reference implementation, \saOf{S} holds the state specific to subnet \subnetName{S}. However, the aforementioned entry point for all functionality is the \gw, and not the \sa. A subnet can augment the default functionality of the \gw in the \sa. In particular, the \sa can include conditions for the validation of proofs of finality, releases of funds and stake, and slashing rules\footnote{the reference implementation does not provide any slashing rule at the time of writing, but provides the mechanism to define slashing rules in the \sa.}.
% In particular, the state of \saOf{C} at \subnetName{P} contains: 
% \begin{enumerate}
%     \item {\bf Basic variables and pointers.} These are \subnetName{C}'s membership, a pointer to \subnetName{C}'s \gw, the parent's subnet name \subnetName{P}, a value representing the consensus mechanism used at \subnetName{C} (always Trantor at the moment), and the CID of \subnetName{C}'s genesis block (the first block of the child subnet). 
%     \item { \bf Checkpointing data and rules.} CIDs of generated checkpoints are stored in the \sa, along with \subnetName{C}-specific rules for the verification of checkpoints. We explain checkpointing in detail in~\cref{sec:refimplfunc}. 
%      \item {\bf \subnetName{C}'s finality verification.} The \sa defines the validity of a \pof attached to a state change that happened in \subnetName{C}.
%      We explain the verification of proofs of finality in~\cref{sec:cnetrefimpl}.


% \paragraph{Example.} We illustrate the interactions between the \gw as entry point and the \sa for subnet customization with an example. Let $u$ be a user with an account \accountName{a} at a subnet \subnetName{P} that implements a gaming platform. Suppose $u$ has joined a tournament at subnet \subnetName{P/C\textsubscript{T}} that has a registration cost of $c$. To do so, $u$ joins the tournament via submitting at \subnetName{P} a transaction $tx=$ \subnetName{P}.\gw.\funcName{Deposit}\funcParam{(\subnetName{P/C\textsubscript{T}}, $c$)} signed with account $a$. However, the tournament restricts registration to accounts with a rating of over $threshold$. This is a subnet-specific restriction defined at \saOf{C\textsubscript{T}}. In the reference implementation, the execution of \subnetName{P}.\gw.\funcName{Deposit}\funcParam{(\subnetName{P/C\textsubscript{T}}, $c$)} invokes a check of \subnetName{P}.\saOf{C\textsubscript{T}}.\funcName{Deposit}\funcParam{($a$, $c$)} that will succeed only if $a.rating> threshold$, and fail otherwise. If the check fails, then the top-down transaction is not propagated to \subnetName{C\textsubscript{T}} and $u$ will not be able to play the tournament. Otherwise, $u$ will be able to join by depositing the cost $c$ in $\subnetName{P}$'s \gw.

%   \marko{frankly,  I am not following this... Please re-read and try to explain being more concrete. Examples help. }\arp{Rewrote, lmk if still not clear}
%   \matej{Even after the re-write, it is still not quite clear to me. We need to be able to answer the question "What does the reader learn from this?" It feels like unless the reader already knows many details of the actual implementation (which even I don't know), things are described here for no obvious purpose (come a bit out of the blue). It could be that this section comes too early and would make more sense as a summary of what has already been described. (Same for \sa's state.)}\arp{I added pointers to where each of the items of the state are explained if not already explained, and merge the state itemize with the actual text for clarity. What are
% concrete examples of something that is not clear enough of this
% section? what do you think are other details of
% the reference implementation not already mentioned that the reader
% should know for this section?}

%  \paragraph{Reusing checkpoints' \pof.}
% Therefore, a child's transaction (or state) \tx is accepted by the parent as final by providing a \pof containing enough signatures amounting for at least $2/3$ of the voting power in the child running an instance of Trantor. The current implementation relies on collecting multiple signatures from replicas, with simple incentives to participate listed in~\cref{sec:refimplincentives}\footnote{A next step in the implementation road-map is to offer a threshold signature mechanism instead of using a multisig. For now, multisigs serve the purpose of an MVP implementation.}. This \pof is the same one used for checkpoints, as bottom-up transactions are batched there (see~\cref{sec:refimplfunc}). In other words, given transaction $tx$, the \prf($tx$) needed for bottom-up transactions is a CID to the latest block decided by the child's Trantor, which already contains a certificate to verify finality. The parent s\textbf{}ubnet considers the \prf valid if it contains signatures from replicas with at least $2/3$ of the voting power in the child. The $2/3$ bound yields the optimal resilience to Byzantine faults for the partially synchronous Trantor \TODO{references}. It also is the optimal bound for interactions between subnets in partial synchrony\TODO{references}.

\subsection{Functionality} 
\label{sec:refimplfunc}
In this section, we describe the implementation of the functionality. In the reference implementation, cross-net transactions are the cornerstone of interactions between IPC subnets. Deposits, withdrawals, staking and releasing collateral, and state changes across subnets are all implemented with cross-net transactions.

\subsubsection{Deposits}
The main difference of deposits in the reference implementation compared to the high-level description is that \saOf{C} does not hold the funds being deposited to subnet \subnetName{C}. Additionally, the reference implementation explicitly addresses incentives by requiring an IPC fee in each cross-net transaction. In particular, depositing \funcParam{amount} coins from an account \accountNameFull{P}{a} in the parent subnet \subnetName{P} to an account \accountNameFull{P/C}{b} in the child subnet \subnetName{P/C} is performed in the following steps:

\begin{enumerate}
    \item The owner of $\accountNameFull{P}{a}$ submits a transaction $tx=$ \subnetName{P.}\gw.\funcName{Deposit}(\subnetName{P/C}, \funcParam{b, amount, IPCfee}).
    \item $tx$ is ordered and executed at \subnetName{P}. The ordering and execution of $tx$ is as follows:
    \begin{itemize}
        \item \gw checks that \funcParam{IPCfee} is above a hard-coded minimum IPC base fee. The parameter \funcParam{IPCfee} is an amount of coins to be paid to the child replicas to incentivize them to participate in the validation of top-down transactions for the child\footnote{The IPC fee is different from and in addition to transaction fees for replicas to order and execute transactions in a subnet, which we mention in~\cref{sec:preliminaries} but otherwise omit in each transaction throughout the document.} (see~\cref{sec:cnetrefimpl}). 
        % \item \gw calls on \subnetName{P}.\saOf{C} to perform subnet-specific checks, should there be any,
        \item \funcParam{amount} is deposited in the \gw of the parent subnet.
        \item \gw creates a top-down transaction $tx'=$ \subnetName{P/C}.\gw.\funcName{MintDeposited}(\funcParam{b, amount, IPCfee}) and stores it in the \tqueue (see~\cref{sec:cnetrefimpl}).
        \item The top-down transaction $tx'$ is ordered and executed at the child subnet, resulting in the minting of \funcParam{amount} sent to account \accountNameFull{P/C}{b}. We detail further the ordering and execution of top-down transactions in~\cref{sec:cnetrefimpl}.
    \end{itemize}
\end{enumerate}

\subsubsection{Withdrawals}
Analogously to deposits, withdrawals must carry an IPC fee to be paid to the child replicas, and the funds to be released back at the parent subnet \subnetName{P} are being held at \subnetName{P}.\gw. Otherwise, the procedure is analogous to the one described in~\cref{sec:functionality}. More concretely, withdrawing \funcParam{amount} coins from an account \accountNameFull{P/C}{b} in the child subnet \subnetName{P/C} to an account \accountNameFull{P}{a} in the parent subnet \subnetName{P} involves the following steps:
\begin{itemize}
\item The owner of \accountNameFull{P/C}{b} submits a transaction $tx=$ \subnetName{P/C.}\gw.\funcName{Withdraw}(\funcParam{amount, a, IPCfee}).
 \item $tx$ is ordered and executed at \subnetName{P/C}. The ordering and execution of $tx$ is as follows:
 \begin{itemize}
        \item \gw checks that \funcParam{fee} is above a hard-coded minimum IPC base fee. The parameter \funcParam{IPCfee} is an amount of coins to be paid to the child replicas to incentivize them to participate in the validation of bottom-up transactions for the child (see~\cref{sec:cnetrefimpl}). 
        % \item \gw performs subnet-specific checks, should there be any.
        \item \funcParam{amount} is burned from \accountName{b}.
        \item \gw creates a bottom-up transaction $tx'=$ \subnetName{P}.\saOf{C}.\funcName{ReleaseWithdrawn}(\funcParam{amount, b, IPCfee}) and stores it in the \bqueue (see~\cref{sec:cnetrefimpl}).
        \item The bottom-up transaction $tx'$ is ordered and executed at the parent subnet. This results in \saOf{C} calling \gw to release \funcParam{amount} and send it to account \accountNameFull{P}{a}. We detail further the ordering and execution of bottom-up transactions in~\cref{sec:cnetrefimpl}.
    \end{itemize}
\end{itemize}

\subsubsection{Checkpointing} 
\label{sec:refimplcheck} A checkpoint of a subnet \subnetName{P/C} is triggered every $\Delta$ blocks decided at the child subnet. If the latest block decided meets this condition, and if the participant's full node is a replica according to the state stored at the parent, then the IPC agent starts computing the checkpoint as follows:
\begin{enumerate}
    \item The IPC agent obtains a state snapshot from the child's subnet. The state snapshot is a CID \funcParam{chkpCID} of the latest decided block of the child's subnet that contains a checkpoint certificate as \pof  (recall that every $\Delta$-th block contains a checkpoint certificate in Trantor). The \pof of the checkpoint is the certificate of the block.
    \item The IPC agent obtains the CIDs of all new grandchildren's checkpoints stored at \subnetName{P/C}.\gw.\dataField{gcChkps} and of the bottom-up transactions in the \bqueue \dataField{BUpTxs} (see~\cref{sec:cnetrefimpl}). Explicitly checkpointing children checkpoints recursively bubbles up the security anchor from lower levels of the hierarchy.
    \item The IPC agent submits $tx=$\subnetName{P}.\saOf{C}.Checkpoint(\subnetName{P/C}, \funcParam{chkpCID, gcChkps, BUpTxs}, \pof).
    \item The \saOf{C} verifies the validity of the \pof, saves the checkpoint CID in its state and calls on \gw to save all checkpoints' CIDs (those of \subnetName{P/C}'s children and of \subnetName{P/C}) and to execute all bottom-up transactions attached to the checkpoint. If the \pof is not valid according to the state at \saOf{C}, then the entire checkpoint will fail.
\end{enumerate}
% \begin{algorithm}[H]
% \footnotesize
% \caption{Checkpoints \impl \label{alg:chkpsimpl}}
%   \DontPrintSemicolon
%   \SetKwFunction{FMain}{Global}
%   \SetKwProg{Pn}{Function}{:}{\KwRet}
%   \SetKwInOut{Input}{input}
%   \SetKwProg{Component}{$\blacktriangleright$ \bf}{:}{\KwRet}
%   \SetKwFor{UponKW}{upon}{do}{fintq}
%    \Component{IPC agent}{
%    \UponKW{\dataField{newBlock} \text{from subnet \subnetName{C}}}{
%         \If{\dataField{newBlock}.\dataField{blockheight} $\bmod$ $\Delta$ $=0$}{
%             \If{\subnetName{P}.\saOf{C}.\funcName{isReplica}\funcParam{(Self)}}{
%                 \dataField{chkpCID} $\gets$ \dataField{newBlock}.\funcName{GetCID()}\;
%                 \dataField{gcChkps} $\gets$ \subnetName{C}.\gw.NewChkps() \tcp*[r]{grandchildren's chkps}
%                 \dataField{BUpTxs} $\gets$ \subnetName{C}.\gw.\dataField{BottomUpRegistry}\;
%                 submit \subnetName{P}.\gw.\funcName{Checkpoint(\subnetName{P/C}, \dataField{chkpCID, gcChkps, BUpTxs})}\;
%             }
%         }
%         }
%   }
%     \Component{\subnetName{P}.\gw.\funcName{Checkpoint}\funcParam{(\subnetName{P/C}, chkpCID, gcChkps, BUpTxs)}}{
%   \If{\subnetName{P}.\saOf{C}.\funcName{Checkpoint}\funcParam{(chkpCID, gcChkps, BUpTxs)}}{
%     Save \funcParam{chkp} in the state\;  
%     Execute \dataField{tx},  $\forall$ \dataField{tx} $\in$ \funcParam{chkp.\dataField{BUpTxs}}
%     Save \funcParam{chkp} in the state\;
%   }  
%   }
%   \Component{\subnetName{P}.\saOf{C}.\funcName{Checkpoint}\funcParam{(chkpCID, gcChkps, BUpTxs)}}{
%   \tcp*[l]{[subnet-specific treatment of checkpoints and bottom-up txs]}
%     \textbf{return} \subnetName{P}.\saOf{C}.\funcName{verify}\funcParam{(chkpCID, gcChkps, BUpTxs)}\tcp*[r]{\pof is \texttt{newBlock}'s certificate}
%     % \subnetName{P}.\gw.\funcName{Checkpoint}(\funcParam{P/C, chkp})
%     }
%   % \Component{\subnetName{P}.\gw.\funcName{Checkpoint}\funcParam{(P/C, chkp)}}{
%   % Save \funcParam{chkp} in the state\;
%   % Execute \dataField{tx},  $\forall$ \dataField{tx} $\in$ \funcParam{chkp.\dataField{BUpTxs}}
%   % }
  
% \end{algorithm}

\subsubsection{Propagating cross-net transactions}
\label{sec:cnetrefimpl} 
Similarly to the description in~\cref{sec:functionality}, the current reference implementation uses the \postoffice in each \gw to propagate cross-net transactions to a subnet not immediately adjacent by submitting multiple cross-net transactions in the parent-child hierarchy (one in each subnet along the path to the destination subnet). As shown in~\cref{sec:functionality}, a cross-net transaction $tx$ is propagated to each immediately adjacent subnet along the path to its destination by traversing through the \postoffice of all intermediate subnets, via cross-net transactions $tx'(tx)$ containing $tx$ as payload. 

However, once $tx'$ is ordered and executed at an intermediate subnet \subnetName{S}, an IPC agent must pay for the cost to pay the fees for ordering and executing another transaction $tx''(tx)$ in \subnetName{S} so as to move the state to the next subnet along the path. For this reason, the reference implementation leaves $tx$ in the \postoffice of that intermediate subnet until the account that originally triggered the cross-net transaction creates $tx''$ and pays for the fees required to execute it\footnote{a whitelist of accounts that are allowed to create and pay can be provided.}. This process is repeated until $tx$ reaches its destination subnet.

 As a result, a cross-net transaction that has been paid for leaves the \postoffice to join a FIFO queue, known as either \emph{the \bqueue} or \emph{\tqueue}. All three, \postoffice, \bqueue and \tqueue, contain cross-net transactions and are part of the state of \gw, but only those transactions in either \tqueue or \bqueue are propagated. Transactions in the \tqueue (resp. \bqueue) at \subnetName{P}.\gw are top-down (resp. bottom-up) transactions.

% More concretely, suppose an account \accountName{a} submits a transaction in a child subnet \subnetName{G/P$_1$/C} that triggers a state change in its uncle subnet \subnetName{G/P$_2$}. Then, the cross-net transaction $tx$ that represents that state change must reach the grandparent through the intermediate parent subnet \subnetName{P$_1$}. In the reference implementation, this means that first a bottom-up transaction $tx_{b_1}(tx)$ with $tx$ as payload, \subnetName{C} as source and \subnetName{P$_1$} as recipient is submitted to \subnetName{P$_1$}'s \postoffice from \subnetName{C}'s \bqueue. Once $tx_{b_1}$ is ordered and executed at \subnetName{P$_1$}, \accountName{a} needs to pay for the cost of moving $tx$ into \subnetName{P${_1}$}'s \bqueue, creating a new transaction $tx_{b_2}(tx)$ with $tx$ as payload, \subnetName{P${_1}$} as source and \subnetName{G} as recipient. Following, $tx_{b_2}$ is ordered and executed at \subnetName{G}, reaching the \postoffice at \subnetName{G}. Finally, once \accountName{a} pays to create a transaction $tx_{t_1}(tx)$ with $tx$ as payload, \subnetName{G} as source and \subnetName{P$_2$} as recipient, can $tx_{t_1}$ be ordered an executed, meaning that $tx$ reaches the \postoffice at its destination, and will be executed once one last account pays for its ordering and execution at \subnetName{P$_2$}. 

% \paragraph{Nonce.} Once a subnet orders and executes cross-net transactions, the \gw updates its state by increasing a nonce specific for the recipient subnet (i.e. the parent if bottom-up or the specific child if top-down). The nonce is necessary to avoid replay attacks. We detail now the particularities of top-down and bottom-up transactions. 

\paragraph{Top-down transactions.}

 In order to prevent inconsistencies across replicas, the IPC agent does not immediately submit a top-down transaction to the child subnet. Instead, \ipc agents consistently broadcast the top-down transactions they consider as final at the parent subnet. Also, as an optimization, the IPC agent batches top-down transactions in a \emph{\tcheckpoint} that is consistently broadcast to other replicas every $\Delta_T$ blocks. In this consistent broadcast, an IPC agent broadcasts batches of top-down transactions that it locally considers as valid, and it in turn signs a received batch if it considers all transactions of the batch as valid. As such, the $\pof$ of a top-down transaction $tx$ is obtained once enough signatures to form a certificate\footnote{In Trantor, a certificate for the batch consists of at least enough replicas containing a supermajority of the voting power sign the batch.} are received for a batch containing $tx$.

A participant running a straggling parent full node that receives a certificate for a batch as \prf, but that does not locally see all transactions of the batch as valid, can instead verify the \prf. Once the IPC agent verifies a certificate for a batch of transactions, the IPC agent submits the batch to the child subnet for ordering and execution. 

% This way, when a supermajority of correct child replicas locally see and consider the corresponding transaction at the parent as final in their parent subnet, the rest of the replicas can instead verify the certificate to update the state of the child subnet, preventing inconsistencies with participants running straggling parent replicas. 
    % \del{ In order to consider a transaction \tx at the parent as final, we use the fact that a participant has view into a version of the parent subnet (through its local parent replica process) \jorge{not sure what this means}. In this case, the \prf contains the block height~$h$ (and pointer to that block) at the parent subnet. A child replica then asserts in its parent that the state is final by checking its local version of the parent blockchain at height~$h$. If the local version at the parent replica did not reach height~$h$ yet, the child replica considers the state to currently be non-final/non-valid. The child replica checks again when the parent replica reaches height~$h$.}

\paragraph{Bottom-up transactions.}  
The child subnet aggregates bottom-up transactions attaching their corresponding CIDs to the next checkpoint, along with an increasing nonce value per CID that is unique for each parent-child pair\footnote{the nonce value is necessary to prevent replay attacks}. The CIDs of these bottom-up transactions are placed in the \gw of the child. Bottom-up transactions are stored in the \gw of the child until it is time to checkpoint to the parent (see~\cref{sec:refimplcheck}). This way, the \gw serves as the single location for the CIDs of bottom-up transactions and the IPC agent only needs to monitor the \gw to get all necessary information from the child subnet. As shown in~\cref{sec:refimplcheck}, since the CIDs of bottom-up transactions are attached to the checkpoint, the propagation of bottom-up transactions depends on the validity and execution of the checkpoint transaction. 

% Although omitted in~\cref{alg:chkpsimpl}, executing each \dataField{tx} in \funcParam{chkp.}\dataField{BUpTxs} may require additional checks by the \sa. An example is a withdrawal of funds or a release of collateral for a replica leaving the subnet, that will require a call to check validity of the withdrawal transaction by calling the subnet's \saOf{C}. Recall that checkpoint transactions are only atomically executed if all transactions of the batch are valid and are executed as well.

\subsubsection{Creating and removing a child subnet} Analogously to~\cref{sec:functionality}, subnets are created by instantiating a new \sa and registering the \sa in \gw. When the \gw contains a minimum amount of collateral stored associated with \sa (where enough is defined in the \gw), the subnet can be registered in \gw. 
% This registration in the \gw is what allows this subnet to interact with the rest of subnets registered in IPC through \gw, and thus we refer to it as the creation of the subnet. 

A subnet \subnetName{P/C} is removed from IPC in three steps. First, all users must withdraw their funds to set the circulating supply to zero. Second, all validators leave and release their collateral. Third, any account sends a \subnetName{P}.\gw.\funcName{kill}(\funcParam{\subnetName{C}}) transaction to the \gw that marks the subnet as removed.

\subsubsection{Staking and releasing collateral}
Contrary to~\cref{sec:functionality}, staking collateral does not require a explicit call to update any state in the \gw of the child subnet. A replica simply increases its stake with account \accountNameFull{P}{a} by submitting a transaction \tx{tx} = \funcNameFull{P}{\gw}{StakeCollateral}(\accountNameFull{P}{a}, \funcParam{replica}, \funcParam{amount}). This transaction stakes the collateral in the \gw of the parent \subnetName{P}. Notwithstanding, it does not incur a reconfiguration in the weights of the replica set running the Trantor protocol at the child subnet \subnetName{P/C}. Instead, it is up to the current replica set at \subnetName{P/C} to decide when and how to update their membership to reflect this change of the relative voting power, and notify the new reconfiguration to \subnetName{P}.\gw with a bottom-up transaction. 

A reconfiguration transaction \tx{tx} = \funcNameFull{P}{\saOf{C}}{UpdateMembership}(\funcParam{membership}, \pof) being submitted to the parent can also trigger a release of collateral \tx{tx} = \funcNameFull{P}{\gw}{ReleaseCollateral}(\funcParam{membership}) to reflect this update in the weighted voting of the child subnet. It is possible that a reconfiguration triggers a release of collateral that drops the staked collateral below the minimum threshold for subnet creation. IPC subnets of the reference implementation must always hold this minimum amount of collateral per subnet (defined in the \gw). If, after it has been created and registered, the subnet's collateral drops below the required minimum, then the subnet enters an \emph{inactive} state. This means that the subnet can no longer interact with the rest of the active subnets registered in the \gw, or even withdraw funds back to the parent subnet. In this case, though, users and remaining replicas can stake enough collateral to reactivate the subnet. 
\subsection{Incentives} 
\label{sec:refimplincentives}
In the current reference implementation, replicas get rewarded for executing the checkpoint algorithm and participating in the \tcheckpoint by charging an IPC fee on all cross-net transactions. This incentivizes replicas to participate, even if that costs them a fee to be paid for the transaction at the parent. All cross-net transactions must contain a fixed amount known as IPC fee (on top of the standard transaction fee required for ordering and execution of the transaction in the corresponding subnet). The IPC fee is only paid once the checkpoint (or \tcheckpoint) is ordered and executed. However, no specific incentives are given at the moment to the submitter(s) of the checkpoint transaction, or to the signers of the certificate, in that the sum of IPC fees of the batch is evenly distributed proportionally to the stake of each replica in the membership. This can lead to equilibria in which some participants are incentivized neither to submit checkpoints nor participate in generating a 
\pof. We are currently working in more complex incentive-compatible mechanisms that ensure rational participants will follow the protocol for the reference implementation, via rewards and slashing.
% \del{ The \impl makes certain implementation decisions that affect the design of checkpoints, particularly:
% \begin{enumerate}
% \item The \gw stores the checkpoints from all subnets, instead of having each subnet store their respective checkpoints at their specific \sa.
% \item Checkpoints are triggered periodically after $\Delta$ blocks are decided at the child
% \item cross-net transactions are batched together with checkpoints and forwarded to the parent following checkpoint triggers.
% \end{enumerate}
% }

% \del{\TODO{Discuss/verify} These implementation decisions come with a number of advantages. First, parent and child subnets periodically synchronize following predictable events. Second, having the \gw store all checkpoints easily enables batching of checkpoint transactions with cross-net transactions. Third, this batching inherently provides participation incentives for replicas to submit checkpoints, as they will be rewarded with the IPC fee from cross-net transactions.\guy{I would say that the third point is a problem not an advantage. It entangles checkpointing with cross-net transactions and might make checkpoints depend on the cross-net transactions for incentivation.} \arp{Agreed, but iiuc we will not have other incentives by M2/M3 for checkpoints, so some incentives are better than none at all for checkpoints. But yes, down the road we should work on independent checkpoint incentives (governance account).}}
