 % - Implementations/templates
 %  - Different types and trade-offs of checkpoint triggers 
 %    - Periodically: time, #blocks, #withdrawn, etc.
 %    - At request: (this one is not governance funded)
 %    - Combinations of these 
 %    - Slashing functions
 %    - Atomic execution types?
 \section{An Instance of IPC}
 \label{sec:impl-tmpl}
 Here we describe the particular choices implemented by the Consensus Lab team for the reference implementation of IPC.  
 The current implementation considers Filecoin as the root subnet, and Trantor as child subnets. For our interest it is important to note that Trantor is a BFT consensus protocol with immediate finality, and Filecoin is a longest chain style protocol with probabilistic finality. 
 
 The two main conceptual choices in our implementation are: (i) batching upward transactions -- both from the same type as well as batching different kinds of transactions together (which includes withdrawals, checkpointing and \postoffice transactions); \ (ii) using multisigs for verifying finality of a child state, and local finality check for the finality of a parent state.


\paragraph{Batching through the \gw.}
All upward transactions are made via the \gw of the child. The transactions are batched there until it is time to checkpoint at the parent (specifically, every $\Delta$ child blocks). This way the \gw also serves as the single data structure (queue) storing the upward transactions, therefore, the agent only checks this single place to get all necessary info from the child subnet.
When the checkpoint batch is executed at the parent, it is done atomically. Since \postoffice transactions are included in the batch, the atomic execution of the batch also depends on the \postoffice functionality at the parent handling those messages which lays in the \gw. Therefore, \sa first commits the cid of the checkpoint batch without executing the included transactions, and then triggers the \gw to examine the batch as well. The \gw checks whether there are sufficient funds to handle the \postoffice transactions in the batch. If the funds are insufficient, the entire checkpoint batch fails. If the \gw approves the batch, then it is executed --- both at \sa and at \gw.%
\footnote{Batching the \postoffice transactions together with the checkpoint and withdrawals, as well as entangling the \gw functionality (\postoffice transactions) with the \sa functionality (withdrawals and checkpoint transactions) in a single atomic execution are design choices. This choice benefited the development velocity by having a single mechanism to handle everything and by transferring the responsibility of re-transmitting failed \postoffice transactions to the validators rather than it being the responsibility of \sa (which requires logic implementation).\guy{Alfonso, please explain...}}


 \paragraph{Checking for Finality.}
 Recall that we use Trantor as the consensus engine for child subnets. Therefore, a transaction (or state) \tx is accepted as final by providing a \prf containing 2/3 of the child's validators signatures%
 \footnote{The current implementation relies on collecting multiple signatures. A next step in the implementation road-map is to offer a threshold signature mechanism instead of using a multisig. For now, multisigs serve the purpose of an MVP implementation.} 
 of \tx. 
 In other words, given that \tx is a cid, the parent's subnet call to \sa.\verifyGfinal{\tx}{\prf} returns True iff \prf contains signatures (on \tx) of validators with more than 2/3 of the voting rights in the child. The voting rights are measured according to what is written in \sa for the epoch containing \tx. \arp{I think for M2 we do not actually even have signatures from validators but instead $2n/3$ validators independently submitting the batched checkpoints. The plan is to improve this for M3 I think. REs to verify.}\guy{You're right, but it's too embarrassing to document :-) (and should change quickly)}

 For considering a transaction \tx at the parent as final, we use the fact that a participant has view into a version of the parent subnet (through its local parent replica process). In this case, the \prf contains the block height~$h$ (and pointer to that block) at the parent subnet. A child replica then asserts with its parent that the state is final by checking with its local version of the parent blockchain at height~$h$. If the the local version at the parent replica did not reach height~$h$ yet, the child replica considers the state to currently be non-final/non-valid. The child checks again when the parent reaches height~$h$. \TODO{Verify with REs}

\paragraph{Compressed accounting.}
In \cref{sec:components} we mentioned that \sa.\textit{accounts} can include fine grained accounting data. However, in the current implementation \sa.\textit{accounts} contain a single variable representing the sum of all the individually locked funds at the parent which are dedicated to the child subnet (we call this value \textit{circulating supply}). This has the obvious benefit of reducing the space complexity of \sa.

\paragraph{Incentives?}
Were not the most urgent topic so currently neglected. TBD.\\

The pseudocode of \cref{alg:chkpsimpl} demonstrates the main design choices made by the reference implementation.

\subsection{IPC actors}

\begin{itemize}
\item GWA:
\begin{itemize}
    \item \TODO{Do leaf nodes have a \gw in the \impl?}
    \item GW stores checkpoints of all immediate children (and not each SA).\guy{I'm not sure this is completely true.} \texttimes
    \item GW batches checkpoints messages with other crossnet messages (withdrawals, Postbox, etc.) \checkmark
    \item  Parent Finality verification implicit immediate as soon as transaction locally seen as ordered at parent SMR \checkmark\TODO{Check in code how this is done}
\end{itemize}
\item SA:
\begin{itemize}
    \item Finality verification also implicit (hardcoded, 2n/3 submissions from child's validators, after 2n/3-th ordered at parent, finalized). This will be improved with threshold signatures (off-chain signing by child's validators and one submission, immediate finalization)
    \item SA's Accounting data is the circulating supply \checkmark
    \item No governance account, but \textbf{participation incentives} by: 
    \begin{enumerate}
        \item Additional IPC fee for validators to relay
        \item Incentivizing checkpoint submission as a result of batching with other crossnet messages (which contain the IPC fees), further justifying checkpoints being stored at GW.
        \item Keeping Stake at SA and slashing through fraud proofs
    \end{enumerate} 
\end{itemize}
\end{itemize}
\begin{itemize}
    \item batching: checkpoints + withdrawals
    \item \gw as the place for notifying the agent of upward messages
\end{itemize}
\subsection{Functionality}

\subsubsection{Checkpoints} 
The \impl makes certain implementation decisions that affect the design of checkpoints, particularly:
\begin{enumerate}
\item The \gw stores the checkpoints from all subnets, instead of having each subnet store their respective checkpoints at their specific \sa.
\item Checkpoints are triggered periodically after $\Delta$ blocks are decided at the child
\item Crossnet messages are batched together with checkpoints and forwarded to the parent following checkpoint triggers.
\end{enumerate}

We show in Algorithm~\ref{alg:chkpsimpl} the pseudocode of checkpoints as implemented by the \impl.

\begin{algorithm}[H]
\footnotesize
\caption{Checkpoints \impl}\label{alg:chkpsimpl}
  \DontPrintSemicolon
  \SetKwFunction{FMain}{Global}
  \SetKwProg{Pn}{Function}{:}{\KwRet}
  \SetKwInOut{Input}{input}
  \SetKwProg{Component}{$\blacktriangleright$ \bf}{:}{\KwRet}
  \SetKwFor{UponKW}{upon}{do}{fintq}
   \Component{child SMR replica}{
     \UponKW{new block $b$ decided}{
        notify \texttt{newBlock}($block.height$) to IPC agent
     }
   }
   \Component{IPC agent}{
   \UponKW{notification of \texttt{newBlock}($blockheight$) from child SMR}{
        \If{blockheight $\bmod$ $\Delta$ $=0$}{
                \textit{SA\_state} $\gets$ query parent for \sa's state\;
            \If{\textit{Self} \textbf{in} SA\_state.validators}{
                \textit{state} $\gets$ query child for state\;
                \textit{gcChkps} $\gets$ query child's \gw for grandchildren's checkpoints \;
                \TODO{What is gcChkps used for? gcChkps.crossnetmsgs? ask REs}\;
                \textit{postboxmsgs} $\gets$ query child's \gw for postbox messages\; 
                \textit{pChkps} $\gets$ query parent's \gw for previous checkpoints  \; 
                \textit{cState} $\gets$ \textit{compressState}(\text{state},\textit{pChkps.latestChkp}, gcChkps, postboxmsgs)\;
                create \prf that \textit{cState} is final at child \tcp*[r]{generate certificate containing $2/3$ of the child validators' signatures}
                \TODO{For M2 this is each node submitting to parent?, check with REs}\;
                $\tx=\sa.\texttt{Checkpoint}\left(\textit{cState}, \prf \right)$ \;
                submit $tx$ to parent \smr replica\;
                \TODO{Is it like this? is there a refund?}
            }
        }
        }
  }
  \Component{parent \smr replica}{
    \UponKW{$\tx=\sa.\texttt{Checkpoint}\left(\textit{cState}, \prf \right)$}{
        assert \sa.\verifyGfinal{\textit{cState}}{\prf}\tcp*[r]{Verify certificate}
        $\sa.\textit{latestCheckpoint.update}(\textit{cState})$
     }
  }
  
\end{algorithm}
\TODO{Discuss/verify} These implementation decisions come with a number of advantages. First, parent and child subnets periodically synchronize following predictable events. Second, having the \gw store all checkpoints easily enables batching of checkpoint messages with crossnet messages. Third, this batching inherently provides participation incentives for validators to submit checkpoints, as they will be rewarded with the IPC fee from crossnet messages.\guy{I would say that the third point is a problem not an advantage. It entangles checkpointing with crossnet messages and might make checkpoints depend on the cross-net messages for incentivation.} \arp{Agreed, but iiuc we will not have other incentives by M2/M3 for checkpoints, so some incentives are better than none at all for checkpoints. But yes, down the road we should work on independent checkpoint incentives (governance account).}
